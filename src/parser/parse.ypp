%{
    #include <iostream>

    #include "parse.h"

    #ifndef YYSTYPE
         #define YYSTYPE SyntaxTreeNode*
    #endif

    int yylex(void);
    int yyerror(const char *);

    extern char *yytext;
    extern YYSTYPE yylval;
%}


%define parse.error verbose


%token BININT HEXINT DECINT FLOAT SYMBOL STRING END
%token INTEGER_32 UINTEGER_32 INTEGER_8 UINTEGER_8
%token INTEGER_16 UINTEGER_16 BOOLNAME FLOATNAME DOUBLENAME STRINGNAME
%token CHARNAME INTEGER_64 UINTEGER_64 VOIDNAME
%token EQUALS PLUSEQ MINUSEQ MULTEQ DIVEQ
%token INCREMENT DECREMENT
%token OR AND 
%token BITWISENOT NOT SHR SHL
%token COMP LTE GTE NOTEQ LT GT
%token PLUS MINUS MULT DIV MOD
%token NEWLINE LBRACE RBRACE
%token IF WHILE ELSE

%left MULT DIV
%left PLUS MINUS
%left COMP LTE GTE LT GT NOTEQ
%right PLUSEQ MINUSEQ MULTEQ DIVEQ EQUALS
%left '('

%%
 

Program:
        Function                                            { root->addChild($1);}      
        ;


Function:
        Type Identifier '|' ArgumentList '|' StatementList END
                                                            { $$ = new FunctionDef($1, $2, $4, $6); }


/******************************************/
/* Statements and control flow ************/
/******************************************/

Statement:
        Expression Delimiter
        | VariableDeclaration Delimiter
        | ControlFlowStatement Delimiter
        | Delimiter                                         { $$ = NULL;                        }
        ;

ControlFlowStatement:
        IfStatement
        | WhileStatement
        ;

WhileStatement:
        WHILE Statement StatementList END                   { $$ = new WhileStatement($2, $3);  }
        ;

IfStatement:
        IF Statement StatementList END                       { $$ = new IfStatement($2, $3); }
        | IF Statement StatementList ELSE StatementList END  { $$ = new IfStatement($2, $3, $5);}
        ;

VariableDeclaration:
        Type Identifier                                     { $$ = new VariableDeclaration($1, $2);}
        | Type Identifier EQUALS Expression                 { $$ = new VariableDeclaration($1, $2, $4);}
        ;

StatementList:
        StatementList Statement                             { $1->addChild($2);             }
        | Statement                                         { $$ = new GenericList($1);     }
        ;


Delimiter:
        ';'
        | NEWLINE
        ;
Type:
        SYMBOL                                              { $$ = new Type(yytext);        }
        | INTEGER_32                                        { $$ = new Type(Type::INT32);   }
        | UINTEGER_32                                       { $$ = new Type(Type::UINT32);  }
        | INTEGER_8                                         { $$ = new Type(Type::INT8);    }
        | UINTEGER_8                                        { $$ = new Type(Type::UINT8);   }
        | INTEGER_16                                        { $$ = new Type(Type::INT16);   }
        | UINTEGER_16                                       { $$ = new Type(Type::UINT16);  }
        | INTEGER_64                                        { $$ = new Type(Type::INT64);   }
        | UINTEGER_64                                       { $$ = new Type(Type::UINT64);  }
        | BOOLNAME                                          { $$ = new Type(Type::BOOLEAN); }
        | FLOATNAME                                         { $$ = new Type(Type::FLOAT);   }
        | DOUBLENAME                                        { $$ = new Type(Type::DOUBLE);  }
        | STRINGNAME                                        { $$ = new Type(Type::STRING);  }
        | CHARNAME                                          { $$ = new Type(Type::CHAR);    }
        | VOIDNAME                                          { $$ = new Type(Type::VOID);    }
        ;

ArgumentList:                                               
        ArgumentList ',' Argument                           { $1->addChild($3);            }
        | Argument                                          { $$ = new ArgumentList($1);   }
        | /* empty */                                       { $$ = new ArgumentList();     }
        ;

Argument:
        Type Identifier                                     { $$ = new Argument($1, $2);    }
        ;

Identifier:
        SYMBOL                                              { $$ = yylval;          }
        ;

/********************************************************/
/* Expressions                                          */
/********************************************************/


ExpressionList:                                             
        ExpressionList ',' Expression                       { $1->addChild($3);         }
        | Expression                                        { $$=new GenericList($1);   }
        ;                                

Expression:
        AssignExpression                                    
        ;

AssignExpression:
        AssignExpression PLUSEQ RelationExpression          { $$ = new BinaryOperation(OP_PLUSEQ, $1, $3); }
        | AssignExpression MINUSEQ RelationExpression       { $$ = new BinaryOperation(OP_MINUSEQ, $1, $3);}
        | AssignExpression MULTEQ RelationExpression        { $$ = new BinaryOperation(OP_MULTEQ, $1, $3); }
        | AssignExpression DIVEQ RelationExpression         { $$ = new BinaryOperation(OP_DIVEQ, $1, $3);  }
        | AssignExpression EQUALS RelationExpression        { $$ = new BinaryOperation(OP_ASSIGN, $1, $3); }
        | RelationExpression
        ;

RelationExpression:
        RelationExpression COMP AddExpression               { $$ = new BinaryOperation(OP_COMP, $1, $3);    }
        | RelationExpression LTE AddExpression              { $$ = new BinaryOperation(OP_LTE, $1, $3);     }
        | RelationExpression GTE AddExpression              { $$ = new BinaryOperation(OP_GTE, $1, $3);     }
        | RelationExpression LT AddExpression               { $$ = new BinaryOperation(OP_LT, $1, $3);      }
        | RelationExpression GT AddExpression               { $$ = new BinaryOperation(OP_GT, $1, $3);      }
        | RelationExpression NOTEQ AddExpression            { $$ = new BinaryOperation(OP_NEQ, $1, $3);     }
        | AddExpression
        ;

AddExpression:
        AddExpression PLUS MultExpression                   { $$ = new BinaryOperation(OP_PLUS, $1, $3);    }
        | AddExpression MINUS MultExpression                { $$ = new BinaryOperation(OP_MINUS, $1, $3);   }
        | MultExpression                    
        ;

MultExpression:
        MultExpression MULT UnaryExpression                 { $$ = new BinaryOperation(OP_MULT, $1, $3);    }
        | MultExpression DIV UnaryExpression                { $$ = new BinaryOperation(OP_DIV, $1, $3);     }
        | MultExpression MOD UnaryExpression                { $$ = new BinaryOperation(OP_MOD, $1, $3);     }
        | UnaryExpression
        ;

UnaryExpression:
        NOT PostfixExpression                               { $$ = new UnaryExpression(UNARY_NOT, $2);      }
        | BITWISENOT PostfixExpression                      { $$ = new UnaryExpression(UNARY_BNOT, $2);     }
        | INCREMENT PostfixExpression                       { $$ = new UnaryExpression(UNARY_PREINC, $2);   }
        | DECREMENT PostfixExpression                       { $$ = new UnaryExpression(UNARY_PREDEC, $2);   }
        | PLUS PostfixExpression                            { $$ = new UnaryExpression(UNARY_PLUS, $2);     }
        | MINUS PostfixExpression                           { $$ = new UnaryExpression(UNARY_MINUS, $2);    }
        | PostfixExpression
        ;

PostfixExpression:
        Value '[' Expression ']'                            { std::cout << "TODO: indexing operators ([ ])" << std::endl;}
        | Value '.' SYMBOL                                  { std::cout << "TODO: member access" << std::endl;}
        | Value INCREMENT                                   { $$ = new UnaryExpression(UNARY_POSTINC, $1);  }
        | Value DECREMENT                                   { $$ = new UnaryExpression(UNARY_POSTDEC, $1);  }
        | Value '(' ')'                                     { $$ = new FunctionCall($1, NULL);    }
        | Value '(' ExpressionList ')'                      { $$ = new FunctionCall($1, $3);                }
        | Value
        ;


Value:
        BININT                                              { $$ = yylval;                      }
        | HEXINT                                            { $$ = yylval;                      }
        | DECINT                                            { $$ = yylval;                      }
        | FLOAT                                             { $$ = yylval;                      }
        | SYMBOL                                            { $$ = yylval;                      }
        | STRING                                            { $$ = yylval;                      }
        | LambdaFunction
        | '(' Expression ')'                                { $$ = $2;                          }
        | '[' ExpressionList ']'                            { $$ = $2;                          }
        ;

LambdaFunction:
        LBRACE '|' ArgumentList '|' StatementList RBRACE    { $$ = new LambdaFunction($3, $5);}
        ;


%%

extern int yylineno;

int yyerror(const char *err) {
    std::cout << "Error " << err << " on line " << yylineno << std::endl;
    return 1;
}